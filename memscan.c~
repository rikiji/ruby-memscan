#include <ruby.h>

#include <sys/ptrace.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <linux/ptrace.h>

#define V_PID rb_intern("pid")
#define GETPID() get_and_check_pid(self)
#define RAISE(x) rb_raise(rb_eRuntimeError, x " %s:%d", __FILE__, __LINE__)

static pid_t get_and_check_pid(VALUE self)
{
  VALUE rpid = rb_ivar_get(self,V_PID);
  if(TYPE(rpid) != T_FIXNUM)
    RAISE("pid not set");
  
  pid_t pid = (pid_t)NUM2LONG(rpid);
  if (!pid)
    RAISE("pid not valid");

  return pid;
}

static VALUE
memscan_dump_stack(VALUE self)
{

  rb_funcall(self,rb_intern("memmap"),0);

  pid_t pid = GETPID();
  VALUE stack= rb_ivar_get(self,rb_intern("@stack"));
  unsigned long begin= NUM2ULONG(rb_ary_shift(stack));
  unsigned long end= NUM2ULONG(rb_ary_shift(stack));
  printf("stack size: %d\n",end-begin);

  return Qtrue;

}

static VALUE
memscan_attach(VALUE self)
{
    
  pid_t pid = GETPID();
  if(ptrace(PTRACE_ATTACH,pid, NULL, NULL) < 0) {
    RAISE("attach failed");
  }
  
  int status=0;
  printf("pid %d\n");
  if(rb_waitpid(pid,&status,0)==-1)
    RAISE("waitpid failed");

  /*  int eax = ptrace(PTRACE_PEEKUSER,
                            pid, 4 * EAX, NULL);
  printf ("eax %x\n",eax);
  */
  return Qtrue;
}

static VALUE
memscan_get_pid (VALUE self)
{
  return rb_ivar_get(self,V_PID);
}

static VALUE
memscan_set_pid (VALUE self, VALUE val)
{
  rb_ivar_set(self,V_PID,val);
  return self;
}

void
Init_memscan()
{
  VALUE klass =rb_define_class("Memscan", rb_cObject);
  rb_define_method(klass, "pid", memscan_get_pid, 0);
  rb_define_method(klass, "pid=", memscan_set_pid, 1);
  rb_define_method(klass, "attach", memscan_attach, 0);
  rb_define_method(klass, "dump_stack", memscan_dump_stack, 0);
}
